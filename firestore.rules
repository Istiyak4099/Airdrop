rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CORE PHILOSOPHY
     * This ruleset enforces a strict user-ownership model centered around a private root document for each user.
     * Access is strictly controlled through a hierarchical path structure where the root identifier is the 
     * Firebase Authentication UID.
     *
     * DATA STRUCTURE
     * Most application data is nested under `/userAccounts/{userAccountId}/...`. This allows for implicit 
     * security through path-based authorization. A global collection, `/subscriptionPlans/`, provides 
     * read-only information to all users.
     *
     * KEY SECURITY DECISIONS
     * 1. Authorization Independence: To ensure performant and simple rules, the `userAccountId` is denormalized 
     *    (copied) onto every document within the user's tree. This allows rules to verify ownership 
     *    locally without calling `get()` on parent documents.
     * 2. No User Listing: While users can access their own account details, they are forbidden from listing 
     *    or discovering other user accounts at the root level.
     * 3. Prototyping Flexibility: Rules strictly enforce *who* can write (Authorization), but they do not 
     *    enforce the specific data types or keys of the content (Schema), facilitating rapid iteration.
     * 4. Relational Integrity: On creation and update, rules verify that the internal `userAccountId` or `id` 
     *    fields remain consistent with the authenticated user and the document path.
     */

    // --- HELPER FUNCTIONS ---

    /** Checks if the request is from an authenticated user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** Checks if the authenticated user's UID matches the provided userId. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** Checks if the user is the owner and the document currently exists. */
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    /** Validates that the user is creating a document for themselves and setting their ID correctly. */
    function isCreatingSelf(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /** Validates that the internal ownership link matches the user's path. */
    function isValidOwnership(userId) {
      return request.resource.data.userAccountId == userId;
    }

    /** Ensures that a specific field is not modified during an update. */
    function isUnchanged(field) {
      return !(field in request.resource.data) || request.resource.data[field] == resource.data[field];
    }

    // --- COLLECTION RULES ---

    /**
     * @description Rules for the primary user account document. Users can manage their own account.
     * @path /userAccounts/{userAccountId}
     * @allow (get) if auth.uid matches userAccountId.
     * @deny (list) to prevent user discovery.
     * @principle Self-creation and strict ownership of the root user document.
     */
    match /userAccounts/{userAccountId} {
      allow get: if isOwner(userAccountId);
      allow list: if false;
      allow create: if isCreatingSelf(userAccountId);
      allow update: if isExistingOwner(userAccountId) && isUnchanged('id');
      allow delete: if isExistingOwner(userAccountId);

      /**
       * @description Social media credentials and page links. Private to the user.
       * @path /userAccounts/{userAccountId}/socialMediaIntegrations/{integrationId}
       * @allow (create) if auth.uid matches userAccountId and data.userAccountId is correct.
       * @deny (update) if attempting to change the owning userAccountId.
       * @principle Authorization independence via denormalized userAccountId.
       */
      match /socialMediaIntegrations/{integrationId} {
        allow get, list: if isOwner(userAccountId);
        allow create: if isOwner(userAccountId) && isValidOwnership(userAccountId);
        allow update: if isExistingOwner(userAccountId) && isUnchanged('userAccountId');
        allow delete: if isExistingOwner(userAccountId);

        /**
         * @description Conversation threads for a specific integration.
         * @path /userAccounts/{userAccountId}/socialMediaIntegrations/{integrationId}/conversations/{conversationId}
         * @allow (list) by the owner of the integration path.
         * @deny (create) if integrationId in data doesn't match the path.
         * @principle Validates relational integrity between the path and document fields.
         */
        match /conversations/{conversationId} {
          allow get, list: if isOwner(userAccountId);
          allow create: if isOwner(userAccountId) && isValidOwnership(userAccountId) && request.resource.data.integrationId == integrationId;
          allow update: if isExistingOwner(userAccountId) && isUnchanged('userAccountId') && isUnchanged('integrationId');
          allow delete: if isExistingOwner(userAccountId);

          /**
           * @description Individual messages within a conversation.
           * @path /userAccounts/{userAccountId}/socialMediaIntegrations/{integrationId}/conversations/{conversationId}/messages/{messageId}
           * @allow (create) if conversationId in data matches the path.
           * @deny (update) if the message content or sender info is changed after creation.
           * @principle Enforces path-based consistency and ownership.
           */
          match /messages/{messageId} {
            allow get, list: if isOwner(userAccountId);
            allow create: if isOwner(userAccountId) && isValidOwnership(userAccountId) && request.resource.data.conversationId == conversationId;
            allow update: if isExistingOwner(userAccountId) && isUnchanged('userAccountId') && isUnchanged('conversationId');
            allow delete: if isExistingOwner(userAccountId);
          }
        }
      }

      /**
       * @description AI agent configuration and behavior instructions.
       * @path /userAccounts/{userAccountId}/agentProfiles/{agentProfileId}
       * @allow (create) if owner provides their own userAccountId in the body.
       * @deny (read) if the requester is not the owner of the path.
       * @principle Direct ownership model for sensitive AI instructions.
       */
      match /agentProfiles/{agentProfileId} {
        allow get, list: if isOwner(userAccountId);
        allow create: if isOwner(userAccountId) && isValidOwnership(userAccountId);
        allow update: if isExistingOwner(userAccountId) && isUnchanged('userAccountId');
        allow delete: if isExistingOwner(userAccountId);

        /**
         * @description Pre-defined replies associated with a specific agent.
         * @path /userAccounts/{userAccountId}/agentProfiles/{agentProfileId}/quickReplies/{quickReplyId}
         * @allow (create) if agentProfileId in data matches the path.
         * @deny (delete) if requested by a non-owner.
         * @principle Relational integrity for sub-resources.
         */
        match /quickReplies/{quickReplyId} {
          allow get, list: if isOwner(userAccountId);
          allow create: if isOwner(userAccountId) && isValidOwnership(userAccountId) && request.resource.data.agentProfileId == agentProfileId;
          allow update: if isExistingOwner(userAccountId) && isUnchanged('userAccountId') && isUnchanged('agentProfileId');
          allow delete: if isExistingOwner(userAccountId);
        }
      }

      /**
       * @description Summarized performance metrics for the user dashboard.
       * @path /userAccounts/{userAccountId}/analyticsSummaries/{analyticsSummaryId}
       * @allow (get, list) for the authenticated owner.
       * @deny (write) if the internal userAccountId does not match the authenticated user.
       * @principle Scoped access to private analytics data.
       */
      match /analyticsSummaries/{analyticsSummaryId} {
        allow get, list: if isOwner(userAccountId);
        allow create: if isOwner(userAccountId) && isValidOwnership(userAccountId);
        allow update: if isExistingOwner(userAccountId) && isUnchanged('userAccountId');
        allow delete: if isExistingOwner(userAccountId);
      }
    }

    /**
     * @description Global collection of pricing tiers and features. Read-only for all users.
     * @path /subscriptionPlans/{subscriptionPlanId}
     * @allow (get, list) for any user (public read).
     * @deny (write) for all users (system/admin managed).
     * @principle Public read with administrative-only writes.
     */
    match /subscriptionPlans/{subscriptionPlanId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
  }
}